\chapter{Ontwerp van het project}
\label{hoofdstuk:ontwerp}

Eenmaal de belangrijkste vereisten gekend zijn kan er een ontwerp opgetekend worden. Daarom even de grote lijnen die te concluderen vallen uit hoofdstuk \ref{hoofdstuk:doelen}:

\begin{itemize}
  \item De data en het visuele aspect van de applicatie moeten zo ontkoppeld mogelijk zijn, elk moet apart uitbreidbaar zijn
  \item Zeer grote hoeveelheden data moeten vlot kunnen behandeld worden
  \item De data moet zowel centraal als decentraal toegankelijk zijn en synchronisatie toestaan
  \item Gebruiksvriendelijkheid en snelheid zijn belangrijk
  \item Compatibiliteit met de reeds geschreven onderdelen van het project moet indien mogelijk bewaard blijven
\end{itemize}

Omdat de data de basis is van alle andere delen, zal deze eerst besproken worden.

[citatie software engineering boek, quiza ook gof]

TODO: sommige van deze stukken zouden misschien beter bij motivatie staan, WAAROM wil je doen wat je doet?
(MVC)

Een van de meest fundamentele verschillen tussen de centrale filosofie die Griphos vooropstelt en die van dit project is dat terwijl bij Griphos de focus ligt op aparte geplaatste fragmenten, het thesisproject eerder de automatische gevonden paren behandelt. Het is in Griphos wel degelijk mogelijk om voorstellen van de automatische paarherkenning in te laden maar de naald in de hooiberg vinden is moeilijk.\\

Omgekeerd wordt er bij dit thesisproject steeds vertrokken vanuit de automatisch gegenereerde paren. Om deze reden zijn deze paren ook de centrale eenheid van data.\\

Dit alles wil niet zeggen dat beide aanpakken elkaar uitsluiten, integendeel zelfs. De gevalideerde paren die uit het thesisproject komen kunnen rechtstreeks in een groep op een tafelblad geplaatst worden. In de limiet, wanneer alle mogelijke paren correct geclassificeerd zijn vloeit hieruit op natuurlijk wijze een (zo compleet mogelijk) fresco voort. Daarom valt de implementatie in de thesis te zien als een extra tussenstap, chronologisch v\'o\'or het plaatsen van de fragmenten op een tafelblad en na het uitvoeren van de herkenningsalgoritmen. Figuur \ref{fig:flow} stelt dit visueel voor.



% DATA
\section{Het beheer van de data}

Redenering: Alles vloeit voort uit de paren, het is voorspelbaar (simpel voor te stellen) en ondubbelzinnig

Het zelf kunnen maken van paren is van secundair belang (volgens de thesis), zij kunnen door de HumanMatcher ingevoerd worden in de grote database

Griphos is zeer nuttig -> identificatie locatie van fragmenten in de bak, etc. -> Tangerine is het ontbrekende middendeel!

Dit betekent echter niet dat beide perspectieven elkaar uitsluiten, integendeeel.
 
[TODO: verhuizen naar ontwerp van database]

\subsection{Het oude systeem: XML-bestanden}

E\'en van de belangrijkste stappen op weg naar een collaboratieve applicatie, is het omvormen van\\

Het ontwerp van het database model en de implementatie details zijn groot genoeg om hun eigen hoofdstuk te verdienen, zij worden later in hoofdstuk [...] besproken.\\

\subsection{Ontleding van de data}
...relationeel van aard => SQL database

\subsubsection{Paren}

\subsubsection{Attributen van paren}

\subsubsection{Complexe informatie die niet in een simpel attribuut past}

\subsection{De vereisten van een database ontwerp}
Zoals in sectie [doelen] omschreven moet de applicatie in staat zijn om data op een uitbreidbare manier uit te lezen en te veranderen, liefst zonder 

\subsection{Complexe informatie voorstellen als een attribuut}
Meta-attributen, VIEWs

\subsection{Verschillende iteraties}

\subsection{Databases samenstellen}

\subsubsection{Geschiedenis bijhouden}

% VISUALISATIE
\section{Visualisatie, een manier om met de data te werken}

\subsection{Model-View-Controller}

\subsection{UML diagramma}

[maak UML diagramma]\\

\subsection{GUI}
Met behulp van de Qt toolkit [link]...

Multi-threading voor responsiviteit

\section{Integratie in thera project}
Gebruik van bibliotheken, ...
Extensie door refactoring: FragmentConf -> IFragmentConf ==> SQLFragmentConf | FragmentConf
Hierdoor is het nodig om de reeds bestaande code van het thera project om te zetten naar het gebruik van IFragmentConf waar mogelijk maar het aanmaken van FragmentConf anderzijds
of FragmentConf ==> SQLFragmentConf
Alternatieve oplossing, geen veranderingen in thera code maar SQLFragmentConf sleept dan veel onnodige ballast mee van FragmentConf

\section{Uitbreidbaarheid}
Het programma is ontworpen met uitbreidbaarheid in gedachten. Dit heeft niet enkele betrekking op het klassen-ontwerp maar ook op het dynamisch en statisch verwijderen en toevoegen van modules. Het basissysteem
zonder modules bestaat uit een manier om een fragmenten en paren-database te laden en te kiezen uit welke module op te starten. Het ziet er zo uit: \\

[afbeeldingen invoegen]\\

Een module die ingeladen wordt weet niets over de hoofdapplicatie of andere modules behalve de huidige database. Deze informatie zit vervat in een object dat een model van een aantal paren voorstelt. Dit werd mogelijk gemaakt door een zogenaamde Model-View(-Controller)\footnote{De controller functionaliteit zit in de applicatie verdeeld bij het model en de view} [citatie] aanpak. Een module kan vragen om een applicatie-wijd of een nieuw model te krijgen. Met een applicatie-wijd model kan invloed uitgeoefend worden op andere modules die hetzelfde model gebruiken. Dit is handig bijvoorbeeld als men in \'e\'en module een verzameling paren filtert en selecteert en men een andere module deze selectie wil visualizeren. applicatie-modellen zijn dus bijzonder nuttig voor visualizatie plugins. Om de werkbaarheid van het systeem uit te testen werd een voorbeeldmodule ontwikkeld die alle huidige paren in een grafe plaatst en deze met een ontwarringsalgoritme probeert te plaatsen, zodat men een globaler beeld kan krijgen van de huidige selectie.\\

[afbeelding invoegen, selectie naar grafe transit!]\\